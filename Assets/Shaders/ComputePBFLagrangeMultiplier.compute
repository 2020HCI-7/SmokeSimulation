// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain
#include "UnityCG.cginc"

CBUFFER_START(Params)
	float m_radius;
	float m_k;
	float m_l;
	float m_W_zero;
	float density0;
    int numberOfParticles;
    bool boundaryHandling;
CBUFFER_END

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWStructuredBuffer<float3> x;
RWStructuredBuffer<float> mass;
RWStructuredBuffer<float3> boundaryX;
RWStructuredBuffer<float> boundaryPsi;
RWStructuredBuffer<int> numNeighbors;
RWStructuredBuffer<int> neighbors;
RWStructuredBuffer<float> density;

RWStructuredBuffer<float> lambda;

float W(float3 r)
{
    float res = 0.0;
    float rl = length(r);
    float q = rl/m_radius;

    if (q <= 0.5)
    {
        float q2 = q * q;
        float q3 = q2 * q;
        res = m_k * (6.0 * q3 - 6.0 * q2 + 1.0);
    }
    else
    {
        res = m_k * (2.0 * pow(1.0 - q, 3));
    }
    return res;
}

float3 gradW(float3 r)
{
    float3 res;
    float rl = length(r);
    float q = rl/m_radius;

    if (rl > 0)
    {
        float3 gradq = r * (1.0 / (rl*m_radius));
        if (q <= 0.5)
        {
            res = m_l*q*(3.0 * q - 2.0)*gradq;
        }
        else
        {
            float factor = 1.0 - q;
            res = m_l*(-factor*factor)*gradq;
        }
    }
    return res;
}

float W_zero()
{
    return m_W_zero;
}

[numthreads(256,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    int particleIndex = id.x;
    float c = max(density[particleIndex] / density0 - 1.0, 0.0);
    float lambdaF;

    if (c != 0.0f)
    {
        float sum_grad_C2 = 0.0;
        float3 gradC_i;

        for (int j = 0; j < numNeighbors[particleIndex]; j++)
        {
            int neighborIndex = neighbors[particleIndex*60+j];
            if (neighborIndex < numberOfParticles)
            {
                float3 gradC_j = -mass[neighborIndex] / density0 * 
                    gradW(x[particleIndex] - x[neighborIndex]);
                sum_grad_C2 += length(gradC_j) * length(gradC_j);
                gradC_i -= gradC_j;
            }
            else if (boundaryHandling)
            {
                float3 gradC_j = -boundaryPsi[neighborIndex - numberOfParticles] / density0 * 
                    gradW(x[particleIndex] - boundaryX[neighborIndex - numberOfParticles]);
                sum_grad_C2 += length(gradC_j) * length(gradC_j);
                gradC_i -= gradC_j;
            }
        }

        sum_grad_C2 += length(gradC_i) * length(gradC_i);

        // Compute lambda
        lambdaF = -c / (sum_grad_C2);
    }
    else
    {
        lambdaF = 0.0f;
    }

    lambda[particleIndex] = lambdaF;
}
